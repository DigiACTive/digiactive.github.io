<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[DigiACTive]]></title>
  <link href="http://DigiACTive.github.io/atom.xml" rel="self"/>
  <link href="http://DigiACTive.github.io/"/>
  <updated>2013-12-30T16:15:20+11:00</updated>
  <id>http://DigiACTive.github.io/</id>
  <author>
    <name><![CDATA[DigiACTive Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setting Up Python 2.7 on CentOS 6.4 the (Really) Easy Way]]></title>
    <link href="http://DigiACTive.github.io/blog/2013/12/28/setting-up-python-2-dot-7-on-centos-6-dot-4-the-really-easy-way/"/>
    <updated>2013-12-28T19:23:30+11:00</updated>
    <id>http://DigiACTive.github.io/blog/2013/12/28/setting-up-python-2-dot-7-on-centos-6-dot-4-the-really-easy-way</id>
    <content type="html"><![CDATA[<p>Setting up Python 2.7 on CentOS 6.4 is not particularly easy: CentOS ships with 2.6 and yum seems to depend on it.</p>

<p>The traditional way to do this is to build Python from source, and there is even a <a href="https://github.com/shimizukawa/chef-python-build">Chef cookbook</a> to do this.</p>

<p>However, this is slow, and when you want to verify that your box builds correctly so that your team can start work on it, you want to minimise these sorts of delays. So I (Daniel) have been hunting around for the best way to install pre-built RPMs.</p>

<p>The closest I found was this excellent article from Red Hat: <a href="http://developerblog.redhat.com/2013/02/14/setting-up-django-and-python-2-7-on-red-hat-enterprise-6-the-easy-way/">Setting up Django and Python 2.7 on Red Hat Enterprise 6 the easy way</a>.</p>

<p>To summarise the article, RHEL (and CentOS) support &lsquo;software containers&rsquo;. They&rsquo;re sort of like virtualenvs or RVMs for packages &ndash; isolated, but more lightweight than full chroots. Python 2.7 is a supported container. Not all the steps are the same for CentOS as they are for RHEL, so here&rsquo;s an update of the article for CentOS:</p>

<ul>
<li>CentOS makes it even easier than RHEL to set up the SCLs. Instead of writing random files to your filesystem, you just need to <code>yum install centos-release-SCL</code></li>
<li>You&rsquo;re now ready to do a <code>yum install python27</code></li>
<li>As with RHEL, you can now pop a shell with Python 2.7 by simply doing <code>scl enable python27 bash</code>

<ul>
<li>If you want to run commands with more than one argument, you need to enclose them in quotes, otherwise <code>scl</code> will interpret them as other environments to enable.</li>
</ul>
</li>
</ul>


<p><strong>As long as you are happy running <code>scl enable python27 bash</code> before work, you&rsquo;re now set.</strong></p>

<h1>The gotchas</h1>

<p>While this is much, much faster than building from source, there are two, interrelated gotchas to bear in mind.</p>

<h2>Virtualenvs no longer shield you from interpreter differences</h2>

<p>I naively expected that virtualenvs would &lsquo;just work&rsquo; and would prevent me from having to think about the extra layer of &lsquo;magic&rsquo; I had just added.</p>

<p>I was wrong.</p>

<p>If you create a virtualenv inside scl, and then exit scl and try to run Python, it fails:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">[</span>vagrant@localhost tmp<span class="o">]</span><span class="nv">$ </span>scl <span class="nb">enable </span>python27 bash <span class="c"># enable the Python 2.7 environment</span>
</span><span class='line'><span class="o">[</span>vagrant@localhost tmp<span class="o">]</span><span class="nv">$ </span>virtualenv foo
</span><span class='line'><span class="o">[</span>vagrant@localhost tmp<span class="o">]</span><span class="nv">$ </span><span class="nb">exit</span> <span class="c"># leave the 2.7 environment, back to 2.6</span>
</span><span class='line'><span class="o">[</span>vagrant@localhost tmp<span class="o">]</span><span class="nv">$ </span><span class="nb">source </span>foo/bin/activate
</span><span class='line'><span class="o">(</span>foo<span class="o">)[</span>vagrant@localhost tmp<span class="o">]</span><span class="nv">$ </span>python
</span><span class='line'>python: error <span class="k">while </span>loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directory
</span></code></pre></td></tr></table></div></figure>


<p>You get the same error when you try to create a virtualenv with the newly installed binary outside of scl.</p>

<p>The correct solution is to just wrap everything in scl: making <code>scl enable python27 bash</code> part of your workflow, just like <code>source env/bin/activate</code>.</p>

<h2>Not everything is easy to wrap in scl enable</h2>

<p>For times when it is impossible or very difficult to use scl enable as designed (for example when you&rsquo;re using someone else&rsquo;s chef cookbook), you can work around it. On my 64 bit system, the library it&rsquo;s looking for is in <code>/opt/rh/python27/root/usr/lib64</code>, so you just need to set an environment variable for that:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>env <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>/opt/rh/python27/root/usr/lib64 /opt/rh/python27/root/usr/bin/python
</span></code></pre></td></tr></table></div></figure>


<p>If you&rsquo;re writing a Chef cookbook, you can give an <code>execute</code> block (or similar) an environment parameter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">execute</span> <span class="s2">&quot;foo&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="n">environment</span> <span class="s2">&quot;LD_LIBRARY_PATH&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;/opt/rh/python27/root/usr/lib64/&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Conclusion</h1>

<p>Using a packaged Python is a &ldquo;good thing&rdquo;. The most obvious reason is that of security: if you&rsquo;ve hardcoded a version of Python to download, build and install, and a security hole is found and a new version is released, you&rsquo;ll have to manually update all your recipes. If you&rsquo;re using distro packages, it&rsquo;ll happen more or less automatically in your regular updates.</p>

<p>The second reason distro packages are better is simply that of speed. Time is money: why spend it waiting Python to build?</p>

<p>Hopefully this makes it a bit easier for you all.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Being Part of the Open Source Software Ecosystem]]></title>
    <link href="http://DigiACTive.github.io/blog/2013/12/21/being-part-of-the-open-source-ecosystem/"/>
    <updated>2013-12-21T03:23:08+11:00</updated>
    <id>http://DigiACTive.github.io/blog/2013/12/21/being-part-of-the-open-source-ecosystem</id>
    <content type="html"><![CDATA[<p>At DigiACTive, we&rsquo;re building our solution on top of an open source software stack. Practically, we had a number of reasons for chosing open source, including price, ease of access and cross-platform compatibility. More fundamentally, open source software has played a huge role in bringing technological innovations to those who would otherwise not have had access to them, and that&rsquo;s very much in line with how we see the Digital Canberra Challenge.</p>

<p>It&rsquo;s therefore very exciting to be part of advancing the state of open source software in a couple of small ways.</p>

<h2>Improving django-storage-swift</h2>

<p>We recently submitted a set of patches to <a href="https://github.com/wecreatepixels/django-storage-swift">django-storage-swift</a>, a Python module for interfacing between <a href="http://django.org/">Django</a>, our web framework of choice, and <a href="http://docs.openstack.org/developer/swift/">OpenStack Swift</a>, our object store of choice.</p>

<p>Our main contribution is support for temporary URLs. Temporary URLs provide a way for us to grant users access to their files and their files only in a simple and transparent way. In particular, they are an excellent and simple mechanism for preventing attackers from accessing confidential information by guessing file names. We also improved the out-of-the-box experience for users of django-storage-swift, and made a couple of other minor fixes and improvements.</p>

<p>We&rsquo;ve made our changes available in <a href="https://github.com/DigiACTive/django-storage-swift/tree/digiactive">our fork of the project</a>, and contributed them back to the original project with pull requests.</p>

<h2>Updating the clamav chef cookbook</h2>

<p>We&rsquo;re using <a href="http://docs.opscode.com/chef_solo.html">chef-solo</a> with <a href="http://vagrantup.com/">Vagrant</a> to deploy repeatable environments for development. We recently tried to install <a href="https://github.com/RoboticCheese/clamav">a cookbook</a> to support <a href="http://www.clamav.net/lang/en/">clamav</a> so we can virus scan user-submitted files, but discovered that it&rsquo;s not compatible with the most recent updates to the <a href="https://github.com/opscode-cookbooks/yum#notes">yum cookbook</a>. We&rsquo;ve updated it and submitted the changes back to the original author, and they&rsquo;ve been well received and merged in.</p>

<h2>Looking forward</h2>

<p>We&rsquo;ve been making good progress building our framework and we&rsquo;re looking forward to making increasingly rapid progress towards the Digital Canberra Challenge project!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://DigiACTive.github.io/blog/2013/11/24/hello-world/"/>
    <updated>2013-11-24T16:58:20+11:00</updated>
    <id>http://DigiACTive.github.io/blog/2013/11/24/hello-world</id>
    <content type="html"><![CDATA[<p>Greetings, Internet!</p>

<p>We&rsquo;re DigiACTive, a team of students from the <a href="http://anu.edu.au">Australian National University</a> competing in the inaugural <a href="http://digitalcanberrachallenge.com.au">Digital Canberra Challenge</a>.</p>

<p>We&rsquo;re working with the <a href="http://tams.act.gov.au">ACT Territory and Municipal Services Directorate</a> and <a href="http://nicta.com.au">National ICT Australia</a> to improve the system of obtaining government permits and approvals to hold public events. At the moment, permit applications are long and complex, and it&rsquo;s easy to accidentally forget to submit important documents &mdash; making the process difficult and frustrating for event organisers. On the other side, the government&rsquo;s legacy systems make it hard to track the progress of applications, making the approval process slower than it ought to be. Overall, it&rsquo;s all a bit of a mess!</p>

<p>That&rsquo;s where we come in. Over the next few months, we&rsquo;ll be developing a proof-of-concept system to help both event organisers and government officials keep track of complex applications while making sure they&rsquo;re complying with all the appropriate regulations. Our prototype will help guide the ACT Government as it adopts new technology to replace the existing permits system.</p>

<p>It&rsquo;s early stages at the moment &mdash; we&rsquo;ll try to keep this blog updated as we go so you can have some idea what we&rsquo;re up to. In the meantime, if you&rsquo;ve got some ideas on how to improve the permits system, we&rsquo;d love to hear from you! Contact us at <a href="mailto:digiactive.canberra%20at%20gmail%20dot%20com">digiactive.canberra at gmail dot com</a>.</p>

<p>- The DigiACTive Team</p>
]]></content>
  </entry>
  
</feed>
